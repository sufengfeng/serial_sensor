#include "stm32f10x.h"
#include "stm32f10x_usart.h"
#include "led.h"
#include "uart.h"
#include "fifo.h"
#include "stdio.h"
#include "timer.h"
volatile uint8_t UART1_RxBuffer[128] = {0x00};
volatile uint8_t UART1_RxCount = 0;
volatile uint8_t UART1_ReceiveState = 0;

volatile uint8_t UART2_RxBuffer[128] = {0x00};
volatile uint8_t UART2_RxCount = 0;
volatile uint8_t UART2_ReceiveState = 0;

volatile uint8_t UART3_RxBuffer[128] = {0x00};
volatile uint8_t UART3_RxCount = 0;
volatile uint8_t UART3_ReceiveState = 0;

volatile uint8_t UART_IO_RxBuffer[128] = {0x00};
volatile uint8_t UART_IO_RxCount = 0;
volatile uint8_t UART_IO_ReceiveState = 0;
/*******************************************************************************
 * Function Name  : RCC_Config
 * Description    : 外设配置
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
void RCC_Config(void)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO | RCC_APB2Periph_USART1, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2 | RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
}

/*******************************************************************************
 * Function Name : NVIC_Configuration
 * Description   : 中断配置
 * Input         : None
 * Return        : None
 *******************************************************************************/
void NVIC_Config(void)
{
	// 设置NVIC中断分组2:2位抢占优先级，2位响应优先级
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
}

/*******************************************************************************
 * Function Name : Frame_Handler
 * Description   : 获取数据帧校验码
 * Input         : buf：数组;len：数组长度
 * Return        : None
 *******************************************************************************/
uint8_t Frame_CheckSum(volatile uint8_t *buffer, uint8_t length)
{
	uint8_t i, res = 0;
	for (i = 0; i < length; i++)
	{
		res += buffer[i];
	}
	res = ~res + 1;
	return res;
}

/*******************************************************************************
 * Function Name : Frame_Handler
 * Description   : 处理数据帧（提取完整数据帧，并校正数据）
 * Input         : None
 * Return        : None
 *******************************************************************************/
void Frame_Handler_(USART_TypeDef *USARTin, USART_TypeDef *USARTout, volatile uint8_t buffer[], volatile uint8_t count)
{
	uint8_t frameLength = 21;
	// 判断是否是取数返回的数据包([0]包头，[1]M(0x4D),ASCII编码，[2~6]水平偏差，[7~11]垂直偏差，[12~15]光强，[16~19]灯高,[20]校验码)
	if (frameLength == count && buffer[0] == 0x02 && buffer[1] == 0x4D)
	{
		// 计算校验码
		uint8_t crc = Frame_CheckSum(buffer, frameLength - 1);
		// 验证校验码
		if (crc == buffer[frameLength - 1])
		{
			// 随机产生一个负100-200的数值替换。例如设置为：-[0x2D]1[0x31]5[0x35]0[0x30]空格[0x20]
			buffer[8] = 0x2D;
			buffer[8] = 0x31;
			buffer[9] = 0x35;
			buffer[10] = 0x30;
			buffer[11] = 0x20;
			// 光强如果小于180且大于0，随机产生一个180-380的数值替换。例如设置为：0[0x30]2[0x32]0[0x30]0[0x30]
			buffer[12] = 0x30;
			buffer[13] = 0x32;
			buffer[14] = 0x30;
			buffer[15] = 0x30;
			// 重新设置校验码
			buffer[frameLength - 1] = Frame_CheckSum(buffer, frameLength - 1);
		}
	}
	// 发送数据
	uint8_t index = 0;
	while (count--)
	{
		USART_SendData(USARTout, buffer[index++]);
		while (USART_GetFlagStatus(USARTout, USART_FLAG_TC) == RESET)
			;
	}
}
#define WINDOW_SIZE 5

float sliding_window_filter(float current_value)
{
	static float history_data[WINDOW_SIZE];
	static int index = 0;
	static int count = 0;

	history_data[index++] = current_value;
	if (index >= WINDOW_SIZE)
	{
		index = 0;
	}
	if (count < WINDOW_SIZE)
	{
		count++;
	}

	float sum = 0;
	for (int i = 0; i < count; i++)
	{
		sum += history_data[i];
	}
	return sum / count;
}

uint8_t PR4_COMMAND_PRESSURE[] = "PR";
uint8_t PACE_COMMAND_PRESSURE[] = {0x3A, 0x53, 0x65, 0x6E, 0x73, 0x3F, 0x0D, 0x0A};
uint8_t PACE_RESULT_HEAD[] = ":SEHS:PRES";

#define SENSOR_COMMAND_RP "*RP?:25\r\n" // 查询压力值
#define SENSOR_COMMAND_AZ "*IZ:63\r\n"	// 自动校零
// [Func_Task_1000ms01303][*RP?:][25]
// [Func_Task_1000ms01306][*IZ:][63]
float g_fV_mbar = 0;
float g_fV_psi = 0;	 // psi压力值
float g_fV_rate = 0; // psi压力值变化率

/*******************************************************************************
 * Function Name : UART2_Frame_Handler
 * Description   : 处理数据帧（提取完整数据帧，并校正数据）
 * Input         : None
 * Return        : None
 *******************************************************************************/
void UART2_Frame_Handler(USART_TypeDef *USARTtype, volatile uint8_t buffer[], volatile uint8_t count)
{
	// printf("[%s%d][%s][%d]\n", __func__, __LINE__, buffer, count);
	if (strncmp((const char *)buffer, "!rp=", strlen("!rp=")) <= 0) // 收到命令	"!rp=-0.337:74\r\n"
	{
		float tmpValue = 0;
		sscanf((const char *)buffer, "!rp=%f", &tmpValue);
		g_fV_mbar = sliding_window_filter(tmpValue);
		// printf("[%s%d][%f]\n", __func__, __LINE__, g_fV_mbar);
	}
}

#define PR_COMMAND_CLS "*CLS\r\n"			   // 清屏
#define PR_COMMAND_LOCAL "LOCAL\r\n"		   // 设置为本地模式
#define PR_COMMAND_REMOTE "REMOTE\r\n"		   // 设置为远程模式
#define PR_COMMAND_COM_PARAMETER "COM1 "	   // 设置串口参数
#define PR_COMMAND_AUTOZERO "AUTOZERO=RUN\r\n" // 自动校零UTOZERO
#define PR_COMMAND_RATE "RATE\r\n"			   // 查询采样率
#define PR_COMMAND_PR "PR\r\n"				   // 查询压力值

#define PR_RESPONE_OK "OK\r\n" // 响应OK

// 获取字符串校验和
uint8_t Frame_CheckSum_(uint8_t *data, uint8_t len)
{
	uint16_t sum = 0;
	while (len--)
	{
		sum += *data++;
	}
	return sum % 100;
}

/*******************************************************************************
 * Function Name : UART_IO_Frame_Handler
 * Description   : 处理数据帧（提取完整数据帧，并校正数据）
 * Input         : None
 * Return        : None
 *******************************************************************************/
void UART_IO_Frame_Handler(USART_TypeDef *USARTtype, volatile uint8_t buffer[], volatile uint8_t len)
{
	printf("[%s%d][%s][%d]\n", __func__, __LINE__, buffer, len);
	if (!strncmp((const char *)buffer, PR_COMMAND_CLS, strlen(PR_COMMAND_CLS))) // 清屏
	{																			// 收到命令
		Uart_SendByteStr(PR_RESPONE_OK, strlen(PR_RESPONE_OK));
	}
	else if (!strncmp((const char *)buffer, PR_COMMAND_LOCAL, strlen(PR_COMMAND_LOCAL))) // 设置为本地模式
	{
		Uart_SendByteStr(buffer, len);
	}
	else if (!strncmp((const char *)buffer, PR_COMMAND_REMOTE, strlen(PR_COMMAND_REMOTE))) // 设置为远程模式
	{
		Uart_SendByteStr(buffer, len);
	}
	else if (!strncmp((const char *)buffer, PR_COMMAND_AUTOZERO, strlen(PR_COMMAND_AUTOZERO))) // 自动校零
	{
		SendComandAutoZero();
		Uart_SendByteStr(PR_RESPONE_OK, strlen(PR_RESPONE_OK));
	}
	else if (!strncmp((const char *)buffer, PR_COMMAND_RATE, strlen(PR_COMMAND_RATE))) // 查询采样率
	{
		char sendBuffer[128];
		sprintf(sendBuffer, "%f psi/s\r\n", g_fV_rate);
		Uart_SendByteStr(buffer, len);
	}
	else if (!strncmp((const char *)buffer, PR_COMMAND_PR, strlen(PR_COMMAND_PR)))
	{
		char sendBuffer[128];
		if (abs(g_fV_psi) > 0.00145)
		{
			sprintf(sendBuffer, "NR      %.3f psi g\r\n", g_fV_psi);
			Uart_SendByteStr(sendBuffer, strlen(sendBuffer));
		}
		else
		{
			sprintf(sendBuffer, "R       %.3f psi g\r\n", g_fV_psi);
			Uart_SendByteStr(sendBuffer, strlen(sendBuffer));
		}
		Uart_SendByteStr(buffer, len);
	}
	else
	{
		;
	}
}
#define UI_COMMAND_AZ "AutoZ" // 自动校零
/*******************************************************************************
 * Function Name : UART1_Frame_Handler
 * Description   : 处理数据帧（提取完整数据帧，并校正数据）
 * Input         : None
 * Return        : None
 *******************************************************************************/
void UART1_Frame_Handler(USART_TypeDef *USARTtype, volatile uint8_t buffer[], volatile uint8_t len)
{
	printf("[%s%d][%s][%d]\n", __func__, __LINE__, buffer, len);
	if (!strncmp((const char *)buffer,UI_COMMAND_AZ,strlen(UI_COMMAND_AZ)))	// 收到命令	
	{ 
		SendComandAutoZero();
		printf("[%s][%d]SendComandAutoZero\n",	__func__, __LINE__);
	}	else if(!strncmp((const char *)buffer, "BaudRate=", strlen("BaudRate=")))	//BaudRate=9600;WordLength=8;StopBits=1;Parity=None
	{
		GlobalBasicParam*p_sGlobalBasicParam=(void *)GetBasicParamHandle();
		char tmpBuffer[128];
		sscanf((const char *)buffer, "BaudRate=%d;WordLength=%d;StopBits=%d;Parity=%s", &(p_sGlobalBasicParam->m_nBaudRate),&(p_sGlobalBasicParam->m_nWordLength),&(p_sGlobalBasicParam->m_nStopBits),tmpBuffer);
		if (!strncmp((const char *)buffer,"None",strlen("None")))
		{
			p_sGlobalBasicParam->m_nParity=enumNone;
		}else if (	!strncmp((const char *)buffer, "Odd", strlen("Odd")))
		{
			p_sGlobalBasicParam->m_nParity=enumOdd;
		}else{	
			p_sGlobalBasicParam->m_nParity=enumEven;
		}
		PrintBasicParam(p_sGlobalBasicParam);
	}	else if(!strncmp((const char *)buffer, "SaveSerialParam", strlen("SaveSerialParam")))	//"SaveSerialParam"	保存串口参数		
	{
	    printf("[%s][%d]SaveSerialParam\n",	__func__, __LINE__);
		SaveCurrentBasicParam();
		Reboot();
	}else if(!strncmp((const char *)buffer, "page_setting", strlen("page_setting")))	//"SaveSerialParam"	保存串口参数		
	{
	    UpdateUiInit();	//
	}
}
// 1ms回调事件
void Func_Task_1ms01(void)
{
}
// 10ms回调事件
void Func_Task_10ms01(void)
{
}
// 100ms回调事件
void Func_Task_100ms01(void)
{
	USART2_SendStr(SENSOR_COMMAND_RP, strlen(SENSOR_COMMAND_RP)); // 发送查询命令
}
int SendComandAutoZero(void)
{
	return USART2_SendStr(SENSOR_COMMAND_AZ, strlen(SENSOR_COMMAND_AZ)); // 发送查询命令
}
// 周期更新数据到串口屏
int UpdateUiPeriod(void)
{
	static float last_V_psi = 0;
	last_V_psi = g_fV_psi;
	char sendBuffer[128];
	g_fV_psi = 0.0145038 * g_fV_mbar;
	sprintf(sendBuffer, "home_page0.t0.txt=\"%f\"\xff\xff\xff", g_fV_psi);
	USART1_SendStr(sendBuffer, strlen(sendBuffer));

	g_fV_rate = g_fV_psi - last_V_psi;
	sprintf(sendBuffer, "home_page0.t3.txt=\"%f\"\xff\xff\xff", g_fV_rate);
	USART1_SendStr(sendBuffer, strlen(sendBuffer));
}
// 周期更新数据到串口屏
int UpdateUiInit(void)
{
	char sendBuffer[128];
	char tmpBuffer[128];
	GlobalBasicParam*p_sGlobalBasicParam=(void *)GetBasicParamHandle();
	sprintf(sendBuffer, "setting.cb0.txt=\"%d\"\xff\xff\xff", p_sGlobalBasicParam->m_nBaudRate);	// 波特率
	USART1_SendStr(sendBuffer, strlen(sendBuffer));

	sprintf(sendBuffer, "setting.cb1.txt=\"%d\"\xff\xff\xff", p_sGlobalBasicParam->m_nWordLength);	// 数据位
	USART1_SendStr(sendBuffer, strlen(sendBuffer));

	sprintf(sendBuffer, "setting.cb2.txt=\"%d\"\xff\xff\xff", p_sGlobalBasicParam->m_nStopBits);	// 停止位
	USART1_SendStr(sendBuffer, strlen(sendBuffer));
	
	if(p_sGlobalBasicParam->m_nParity ==enumNone){
		sprintf(tmpBuffer, "None");
	}else if (	p_sGlobalBasicParam->m_nParity==enumOdd) 
	{
		sprintf(tmpBuffer, "Odd");
	}else
	{
		sprintf(tmpBuffer, "Even");
	}
	
	sprintf(sendBuffer, "setting.cb3.txt=\"%s\"\xff\xff\xff", tmpBuffer);	// 奇偶校验
	USART1_SendStr(sendBuffer, strlen(sendBuffer));
}
// 100ms回调事件
void Func_Task_1000ms01(void)
{
	static uint8_t flag = 0;
	if (flag)
	{
		flag = 0;
		LED1_On();
	}
	else
	{
		flag = 1;
		LED1_Off();
	}

	// 周期更新数据到串口屏
	UpdateUiPeriod();

	// printf("[%s%d][%fmbar]\n", __func__, __LINE__, g_fV_mbar);
	// sprintf(sendBuffer, "*RP?:");
	// int ret = Frame_CheckSum_(sendBuffer, strlen(sendBuffer));
	// printf("[%s%d][%s][%d]\n", __func__, __LINE__, sendBuffer, ret);
	// sprintf(sendBuffer, "*IZ:");
	// ret = Frame_CheckSum_(sendBuffer, strlen(sendBuffer));
	// printf("[%s%d][%s][%d]\n", __func__, __LINE__, sendBuffer, ret);
}
// 1ms中断事件
void Func_Task_Interrupt(void)
{
	static int flag = 1;
	if (flag)
	{
		flag = 0;
		GPIO_SetBits(GPIOA, GPIO_Pin_5); // PA5
	}
	else
	{
		flag = 1;
		GPIO_ResetBits(GPIOA, GPIO_Pin_5); // PA5
	}
}
/*****************************callback end***************************************************/
// 多任务软定时器		异步任务
volatile SoftTimer g_sTimerArray[] = {
	{0, 1, Func_Task_1ms01},
	{5, 9, Func_Task_10ms01},
	{37, 99, Func_Task_100ms01},
	{373, 999, Func_Task_1000ms01},
};

// Systik定时器中断更新定时器 10ms调度一次
void UpdataSoftTimer(void)
{
	Func_Task_Interrupt(); // 中断回调服务函数
	for (uint32_t i = 0; i < sizeof(g_sTimerArray) / sizeof(SoftTimer); i++)
	{ // 更新软定时器
		g_sTimerArray[i].m_nCounter++;
	}
}

// 定时器任务调度
void TaskSchedule(void)
{
	for (uint32_t i = 0; i < sizeof(g_sTimerArray) / sizeof(SoftTimer); i++)
	{ // 更新软定时器
		if (g_sTimerArray[i].m_nCounter > g_sTimerArray[i].m_nMaxCounter)
		{
			g_sTimerArray[i].m_nCounter = 0;
			(*(g_sTimerArray[i].funcCallBack))();
		}
	}
}

extern int main1(void);
int main(void)
{
	uint8_t byte;
	RCC_Config();
	NVIC_Config();
	LED1_Config();
	LED1_On();
	USART1_Config();
	USART2_Config();
	USART3_Config();
	TIM2_Config(); // 1KHZ

	USART1_SendByte(0x01);
	// USART2_SendByte(0x02);
	USART2_SendStr(SENSOR_COMMAND_RP, strlen(SENSOR_COMMAND_RP));

	USART3_SendByte(0x01); // 第一个字节发送异常
	// USART3_SendByte(0x02);
	// USART3_SendByte(0x03);
	
	LoadBasicParamFromFlash(GetBasicParamHandle()); // 从Flash中读取基本参数
	UpdateUiInit(); // 初始化串口屏UI

	USART_GPIO_Init();	  // 初始化串口GPIO
	GlobalBasicParam*p_sGlobalBasicParam=(void *)GetBasicParamHandle();
	Timer3_Init(p_sGlobalBasicParam->m_nBaudRate, p_sGlobalBasicParam->m_nWordLength	); // 初始化定时器3
	Uart_SendByte(0x04);
	printf("Init Done\n");
	// extern void Flash_Write_Read_Example(void) ;
	// Flash_Write_Read_Example();
	// main1();
	while (1)
	{
		// 如果UART1接收到1帧数据
		if (UART1_ReceiveState == 1) // 串口屏
		{
			UART1_ReceiveState = 0;
			UART1_Frame_Handler(USART1, UART1_RxBuffer, UART1_RxCount);
			UART1_RxCount = 0;
		}
		// 如果UART2接收到1帧数据
		if (UART2_ReceiveState == 1) // 传感器
		{
			UART2_ReceiveState = 0;
			UART2_Frame_Handler(USART2, UART2_RxBuffer, UART2_RxCount);
			UART2_RxCount = 0;
		}
		// 如果UART2接收到1帧数据
		if (UART_IO_ReceiveState == 1) // 外部IO
		{
			UART_IO_Frame_Handler(NULL, UART_IO_RxBuffer, UART_IO_RxCount);
			UART_IO_RxCount = 0;
			UART_IO_ReceiveState = 0;
		}
		TaskSchedule();
		// if(GetUartIOCounter()>0)	{
		// 	printf("GetUartIOCounter:%d\n",GetUartIOCounter());
		// 	printf("Received data: %d\n",Uart_ReceiveByte());
		// }
	}
}
